package edu.ksu.cis.bandera.specification.assertion.parser;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Bandera, a Java(TM) analysis and transformation toolkit           *
 * Copyright (C) 1998-2001 SAnToS Laboratories (santos@cis.ksu.edu)  *

 * All rights reserved.                                              *
 *                                                                   *
 * This work was done as a project in the SAnToS Laboratory,         *
 * Department of Computing and Information Sciences, Kansas State    *
 * University, USA (http://www.cis.ksu.edu/santos).                  *
 * It is understood that any modification not identified as such is  *
 * not covered by the preceding statement.                           *
 *                                                                   *
 * This work is free software; you can redistribute it and/or        *
 * modify it under the terms of the GNU Library General Public       *
 * License as published by the Free Software Foundation; either      *
 * version 2 of the License, or (at your option) any later version.  *
 *                                                                   *
 * This work is distributed in the hope that it will be useful,      *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *
 * Library General Public License for more details.                  *
 *                                                                   *
 * You should have received a copy of the GNU Library General Public *
 * License along with this toolkit; if not, write to the             *
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,      *
 * Boston, MA  02111-1307, USA.                                      *
 *                                                                   *
 * Java is a trademark of Sun Microsystems, Inc.                     *
 *                                                                   *
 * To submit a bug report, send a comment, or get the latest news on *
 * this project and other SAnToS projects, please visit the web-site *
 *                http://www.cis.ksu.edu/santos                      *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* This file was generated by SableCC (http://www.sable.mcgill.ca/sablecc/). */

import edu.ksu.cis.bandera.specification.assertion.lexer.*;
import edu.ksu.cis.bandera.specification.assertion.node.*;
import edu.ksu.cis.bandera.specification.assertion.analysis.*;
import java.util.*;

import java.io.DataInputStream;
import java.io.BufferedInputStream;
import java.io.IOException;

public class Parser
{
	public final Analysis ignoredTokens = new AnalysisAdapter();

	protected Node node;

	private final Lexer lexer;
	private final ListIterator stack = new LinkedList().listIterator();
	private int last_shift;
	private int last_pos;
	private int last_line;
	private final TokenIndex converter = new TokenIndex();
	private final int[] action = new int[2];

	private final static int SHIFT = 0;
	private final static int REDUCE = 1;
	private final static int ACCEPT = 2;
	private final static int ERROR = 3;

	private static int[][][] actionTable;
/*      {
			{{-1, REDUCE, 0}, {2, SHIFT, 1}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, {11, SHIFT, 5}, },
			{{-1, REDUCE, 12}, },
			{{-1, ERROR, 2}, {11, SHIFT, 12}, },
			{{-1, ERROR, 3}, {11, SHIFT, 13}, },
			{{-1, ERROR, 4}, {3, SHIFT, 14}, },
			{{-1, REDUCE, 19}, },
			{{-1, ERROR, 6}, {12, ACCEPT, -1}, },
			{{-1, REDUCE, 4}, },
			{{-1, REDUCE, 8}, },
			{{-1, REDUCE, 1}, {2, SHIFT, 1}, {7, SHIFT, 15}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, },
			{{-1, REDUCE, 2}, {2, SHIFT, 1}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, },
			{{-1, REDUCE, 6}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, },
			{{-1, ERROR, 12}, {5, SHIFT, 21}, },
			{{-1, ERROR, 13}, {5, SHIFT, 22}, },
			{{-1, ERROR, 14}, {11, SHIFT, 23}, },
			{{-1, ERROR, 15}, {11, SHIFT, 24}, },
			{{-1, REDUCE, 5}, {2, SHIFT, 1}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, },
			{{-1, REDUCE, 9}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, },
			{{-1, REDUCE, 3}, },
			{{-1, REDUCE, 10}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, },
			{{-1, REDUCE, 7}, },
			{{-1, ERROR, 21}, {6, SHIFT, 26}, },
			{{-1, ERROR, 22}, {6, SHIFT, 27}, },
			{{-1, ERROR, 23}, {4, SHIFT, 28}, },
			{{-1, REDUCE, 20}, },
			{{-1, REDUCE, 11}, {8, SHIFT, 2}, {9, SHIFT, 3}, {10, SHIFT, 4}, },
			{{-1, REDUCE, 13}, {2, SHIFT, 1}, },
			{{-1, REDUCE, 15}, {2, SHIFT, 1}, },
			{{-1, ERROR, 28}, {11, SHIFT, 31}, },
			{{-1, REDUCE, 14}, {2, SHIFT, 1}, },
			{{-1, REDUCE, 16}, {2, SHIFT, 1}, },
			{{-1, ERROR, 31}, {5, SHIFT, 32}, },
			{{-1, ERROR, 32}, {6, SHIFT, 33}, },
			{{-1, REDUCE, 17}, {2, SHIFT, 1}, },
			{{-1, REDUCE, 18}, {2, SHIFT, 1}, },
		};*/
	private static int[][][] gotoTable;
/*      {
			{{-1, 6}, },
			{{-1, 7}, {10, 18}, {16, 18}, {29, 18}, {30, 18}, {34, 18}, },
			{{-1, 8}, {11, 20}, {17, 20}, {19, 20}, {25, 20}, },
			{{-1, 9}, },
			{{-1, 10}, {9, 16}, {26, 29}, {27, 30}, {33, 34}, },
			{{-1, 11}, {9, 17}, {10, 19}, {16, 25}, },
		};*/
	private static String[] errorMessages;
/*      {
			"TEndOfLineComment TPre TPost TLocation TId EOF expected.",
			"TEndOfLineComment TPre TPost TLocation EOF expected.",
			"TId expected.",
			"TLBracket expected.",
			"TEndOfLineComment TDot TPre TPost TLocation EOF expected.",
			"EOF expected.",
			"TPre TPost TLocation EOF expected.",
			"TColon expected.",
			"TSemicolon expected.",
			"TRBracket expected.",
		};*/
	private static int[] errors;
/*      {
			0, 1, 2, 2, 3, 4, 5, 1, 6, 4, 1, 6, 7, 7, 2, 2, 1, 6, 1, 6, 6, 8, 8, 9, 4, 6, 1, 1, 2, 1, 1, 7, 8, 1, 1, 
		};*/
	public Parser(Lexer lexer)
	{
		this.lexer = lexer;

		if(actionTable == null)
		{
			try
			{
				DataInputStream s = new DataInputStream(
					new BufferedInputStream(
					Parser.class.getResourceAsStream("parser.dat")));

				// read actionTable
				int length = s.readInt();
				actionTable = new int[length][][];
				for(int i = 0; i < actionTable.length; i++)
				{
					length = s.readInt();
					actionTable[i] = new int[length][3];
					for(int j = 0; j < actionTable[i].length; j++)
					{
						for(int k = 0; k < 3; k++)
						{
							actionTable[i][j][k] = s.readInt();
						}
					}
				}

				// read gotoTable
				length = s.readInt();
				gotoTable = new int[length][][];
				for(int i = 0; i < gotoTable.length; i++)
				{
					length = s.readInt();
					gotoTable[i] = new int[length][2];
					for(int j = 0; j < gotoTable[i].length; j++)
					{
						for(int k = 0; k < 2; k++)
						{
							gotoTable[i][j][k] = s.readInt();
						}
					}
				}

				// read errorMessages
				length = s.readInt();
				errorMessages = new String[length];
				for(int i = 0; i < errorMessages.length; i++)
				{
					length = s.readInt();
					StringBuffer buffer = new StringBuffer();

					for(int j = 0; j < length; j++)
					{
						buffer.append(s.readChar());
					}
					errorMessages[i] = buffer.toString();
				}

				// read errors
				length = s.readInt();
				errors = new int[length];
				for(int i = 0; i < errors.length; i++)
				{
					errors[i] = s.readInt();
				}

				s.close();
			}
			catch(Exception e)
			{
				throw new RuntimeException("Unable to read parser.dat.");
			}
		}
	}
	protected void filter() throws ParserException, LexerException, IOException
	{
	}
	private int goTo(int index)
	{
		int state = state();
		int low = 1;
		int high = gotoTable[index].length - 1;
		int value = gotoTable[index][0][1];

		while(low <= high)
		{
			int middle = (low + high) / 2;

			if(state < gotoTable[index][middle][0])
			{
				high = middle - 1;
			}
			else if(state > gotoTable[index][middle][0])
			{
				low = middle + 1;
			}
			else
			{
				value = gotoTable[index][middle][1];
				break;
			}
		}

		return value;
	}
	private int index(Switchable token)
	{
		converter.index = -1;
		token.apply(converter);
		return converter.index;
	}
	Node new0()
	{
		XPAssertion node3 = null;
		XPComment node2 = null;
		PName node1 = null;
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	Node new1()
	{
		XPAssertion node3 = null;
		XPComment node2 = null;
		PName node1 = (PName) pop();
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	Node new10()
	{
		XPAssertion node3 = (XPAssertion) pop();
		XPComment node2 = (XPComment) pop();
		PName node1 = null;
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	Node new11()
	{
		XPAssertion node3 = (XPAssertion) pop();
		XPComment node2 = (XPComment) pop();
		PName node1 = (PName) pop();
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	Node new12()
	{
		TEndOfLineComment node1 = (TEndOfLineComment) pop();
		AEndOfLineComment node = new AEndOfLineComment(node1);
		return node;
	}
	Node new13()
	{
		XPComment node5 = null;
		TSemicolon node4 = (TSemicolon) pop();
		TColon node3 = (TColon) pop();
		TId node2 = (TId) pop();
		TPre node1 = (TPre) pop();
		APreAssertion node = new APreAssertion(node1, node2, node3, node4, node5);
		return node;
	}
	Node new14()
	{
		XPComment node5 = (XPComment) pop();
		TSemicolon node4 = (TSemicolon) pop();
		TColon node3 = (TColon) pop();
		TId node2 = (TId) pop();
		TPre node1 = (TPre) pop();
		APreAssertion node = new APreAssertion(node1, node2, node3, node4, node5);
		return node;
	}
	Node new15()
	{
		XPComment node5 = null;
		TSemicolon node4 = (TSemicolon) pop();
		TColon node3 = (TColon) pop();
		TId node2 = (TId) pop();
		TPost node1 = (TPost) pop();
		APostAssertion node = new APostAssertion(node1, node2, node3, node4, node5);
		return node;
	}
	Node new16()
	{
		XPComment node5 = (XPComment) pop();
		TSemicolon node4 = (TSemicolon) pop();
		TColon node3 = (TColon) pop();
		TId node2 = (TId) pop();
		TPost node1 = (TPost) pop();
		APostAssertion node = new APostAssertion(node1, node2, node3, node4, node5);
		return node;
	}
	Node new17()
	{
		XPComment node8 = null;
		TSemicolon node7 = (TSemicolon) pop();
		TColon node6 = (TColon) pop();
		TId node5 = (TId) pop();
		TRBracket node4 = (TRBracket) pop();
		TId node3 = (TId) pop();
		TLBracket node2 = (TLBracket) pop();
		TLocation node1 = (TLocation) pop();
		ALocationAssertion node = new ALocationAssertion(node1, node2, node3, node4, node5, node6, node7, node8);
		return node;
	}
	Node new18()
	{
		XPComment node8 = (XPComment) pop();
		TSemicolon node7 = (TSemicolon) pop();
		TColon node6 = (TColon) pop();
		TId node5 = (TId) pop();
		TRBracket node4 = (TRBracket) pop();
		TId node3 = (TId) pop();
		TLBracket node2 = (TLBracket) pop();
		TLocation node1 = (TLocation) pop();
		ALocationAssertion node = new ALocationAssertion(node1, node2, node3, node4, node5, node6, node7, node8);
		return node;
	}
	Node new19()
	{
		TId node1 = (TId) pop();
		ASimpleName node = new ASimpleName(node1);
		return node;
	}
	Node new2()
	{
		XPAssertion node3 = null;
		XPComment node2 = (XPComment) pop();
		PName node1 = null;
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	Node new20()
	{
		TId node3 = (TId) pop();
		TDot node2 = (TDot) pop();
		PName node1 = (PName) pop();
		AQualifiedName node = new AQualifiedName(node1, node2, node3);
		return node;
	}
	Node new3()
	{
		PComment node2 = (PComment) pop();
		XPComment node1 = (XPComment) pop();
		X1PComment node = new X1PComment(node1, node2);
		return node;
	}
	Node new4()
	{
		PComment node1 = (PComment) pop();
		X2PComment node = new X2PComment(node1);
		return node;
	}
	Node new5()
	{
		XPAssertion node3 = null;
		XPComment node2 = (XPComment) pop();
		PName node1 = (PName) pop();
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	Node new6()
	{
		XPAssertion node3 = (XPAssertion) pop();
		XPComment node2 = null;
		PName node1 = null;
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	Node new7()
	{
		PAssertion node2 = (PAssertion) pop();
		XPAssertion node1 = (XPAssertion) pop();
		X1PAssertion node = new X1PAssertion(node1, node2);
		return node;
	}
	Node new8()
	{
		PAssertion node1 = (PAssertion) pop();
		X2PAssertion node = new X2PAssertion(node1);
		return node;
	}
	Node new9()
	{
		XPAssertion node3 = (XPAssertion) pop();
		XPComment node2 = null;
		PName node1 = (PName) pop();
		AUnit node = new AUnit(node1, node2, node3);
		return node;
	}
	public Start parse() throws ParserException, LexerException, IOException
	{
		push(0, null, false);

		List ign = null;
		while(true)
		{
			while(index(lexer.peek()) == -1)
			{
				if(ign == null)
				{
					ign = new TypedLinkedList(NodeCast.instance);
				}

				ign.add(lexer.next());
			}

			if(ign != null)
			{
				ignoredTokens.setIn(lexer.peek(), ign);
				ign = null;
			}

			last_pos = lexer.peek().getPos();
			last_line = lexer.peek().getLine();

			int index = index(lexer.peek());
			action[0] = actionTable[state()][0][1];
			action[1] = actionTable[state()][0][2];

			int low = 1;
			int high = actionTable[state()].length - 1;

			while(low <= high)
			{
				int middle = (low + high) / 2;

				if(index < actionTable[state()][middle][0])
				{
					high = middle - 1;
				}
				else if(index > actionTable[state()][middle][0])
				{
					low = middle + 1;
				}
				else
				{
					action[0] = actionTable[state()][middle][1];
					action[1] = actionTable[state()][middle][2];
					break;
				}
			}

			switch(action[0])
			{
				case SHIFT:
					push(action[1], lexer.next(), true);
					last_shift = action[1];
					break;
				case REDUCE:
					switch(action[1])
					{
					case 0: { Node node = new0(); push(goTo(0), node, true); } break;
					case 1: { Node node = new1(); push(goTo(0), node, true); } break;
					case 2: { Node node = new2(); push(goTo(0), node, true); } break;
					case 3: { Node node = new3(); push(goTo(4), node, false); } break;
					case 4: { Node node = new4(); push(goTo(4), node, false); } break;
					case 5: { Node node = new5(); push(goTo(0), node, true); } break;
					case 6: { Node node = new6(); push(goTo(0), node, true); } break;
					case 7: { Node node = new7(); push(goTo(5), node, false); } break;
					case 8: { Node node = new8(); push(goTo(5), node, false); } break;
					case 9: { Node node = new9(); push(goTo(0), node, true); } break;
					case 10: { Node node = new10(); push(goTo(0), node, true); } break;
					case 11: { Node node = new11(); push(goTo(0), node, true); } break;
					case 12: { Node node = new12(); push(goTo(1), node, true); } break;
					case 13: { Node node = new13(); push(goTo(2), node, true); } break;
					case 14: { Node node = new14(); push(goTo(2), node, true); } break;
					case 15: { Node node = new15(); push(goTo(2), node, true); } break;
					case 16: { Node node = new16(); push(goTo(2), node, true); } break;
					case 17: { Node node = new17(); push(goTo(2), node, true); } break;
					case 18: { Node node = new18(); push(goTo(2), node, true); } break;
					case 19: { Node node = new19(); push(goTo(3), node, true); } break;
					case 20: { Node node = new20(); push(goTo(3), node, true); } break;
					}
					break;
				case ACCEPT:
					{
						EOF node2 = (EOF) lexer.next();
						PUnit node1 = (PUnit) pop();
						Start node = new Start(node1, node2);
						return node;
					}
				case ERROR:
					throw new ParserException(
						"[" + last_line + "," + last_pos + "] " +
						errorMessages[errors[action[1]]]);
			}
		}
	}
	private Node pop()
	{
		return (Node) ((State) stack.previous()).node;
	}
	private void push(int state, Node node, boolean filter) throws ParserException, LexerException, IOException
	{
		this.node = node;

		if(filter)
		{
			filter();
		}

		if(!stack.hasNext())
		{
			stack.add(new State(state, this.node));
			return;
		}

		State s = (State) stack.next();
		s.state = state;
		s.node = this.node;
	}
	private int state()
	{
		State s = (State) stack.previous();
		stack.next();
		return s.state;
	}
}
