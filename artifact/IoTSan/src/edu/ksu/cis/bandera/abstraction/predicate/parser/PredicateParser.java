package edu.ksu.cis.bandera.abstraction.predicate.parser;

/* Generated By:JJTree&JavaCC: Do not edit this line. PredicateParser.java */
import java.util.*;
import java.io.*;

public class PredicateParser/*@bgen(jjtree)*/implements PredicateParserTreeConstants, PredicateParserConstants {/*@bgen(jjtree)*/
  protected JJTPredicateParserState jjtree = new JJTPredicateParserState();
  public PredicateParserTokenManager token_source;
  ASCII_UCodeESC_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[36];
  final private int[] jj_la1_0 = {0x80000000,0x80000000,0x10000000,0x26ae000,0x0,0x26ae000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfeee000,0x0,0xd840000,0x0,0xd840000,0x0,0x0,0x0,0x0,0x8840000,0x0,0x26ae000,};
  final private int[] jj_la1_1 = {0x4000,0x4000,0x0,0x4000,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x0,0x18000000,0x18000000,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x240d1,0x60000000,0x600240d1,0x20000,0x200d1,0x4000,0x2200000,0x2200000,0x2000000,0xd1,0x1000000,0x4000,};
  final private int[] jj_la1_2 = {0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x8,0x10,0x1000,0x2000,0x800,0x4,0x4,0x0,0x3,0x3,0x38000,0x38000,0x180,0x180,0x4600,0x4600,0x180,0x0,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private JJCalls[] jj_2_rtns = new JJCalls[6];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  static final class JJCalls {
	int gen;
	Token first;
	int arg;
	JJCalls next;
  }

  public PredicateParser(PredicateParserTokenManager tm) {
	token_source = tm;
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 36; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  public PredicateParser(java.io.InputStream stream) {
	jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
	token_source = new PredicateParserTokenManager(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 36; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  public PredicateParser(java.io.Reader stream) {
	jj_input_stream = new ASCII_UCodeESC_CharStream(stream, 1, 1);
	token_source = new PredicateParserTokenManager(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jj_gen = 0;
	for (int i = 0; i < 36; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  final public SimpleNode AddSubExpr() throws ParseException {
 /*@bgen(jjtree) AddSubExpr */
  ASTAddSubExpr jjtn000 = (ASTAddSubExpr)ASTAddSubExpr.jjtCreate(this, JJTADDSUBEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList tl = new LinkedList();
  LinkedList el = new LinkedList();
  Token t;
  SimpleNode n;
	try {
	  n = MulDivExpr();
					 el.addLast(n);
	  label_11:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case PLUS:
		case MINUS:
		  ;
		  break;
		default:
		  jj_la1[19] = jj_gen;
		  break label_11;
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case PLUS:
		  t = jj_consume_token(PLUS);
		  break;
		case MINUS:
		  t = jj_consume_token(MINUS);
		  break;
		default:
		  jj_la1[20] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
																tl.addLast(t.image);
		n = MulDivExpr();
					 el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	if (!tl.isEmpty())
	{
	  jjtn000.setExprList(el);
	  jjtn000.setTokenList(tl);
	  {if (true) return jjtn000;}
	} else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public SimpleNode AndExpr() throws ParseException {
 /*@bgen(jjtree) AndExpr */
  ASTAndExpr jjtn000 = (ASTAndExpr)ASTAndExpr.jjtCreate(this, JJTANDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList el = new LinkedList();
  SimpleNode n;
	try {
	  n = BitOrExpr();
					el.addLast(n);
	  label_5:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case SC_AND:
		  ;
		  break;
		default:
		  jj_la1[8] = jj_gen;
		  break label_5;
		}
		jj_consume_token(SC_AND);
		n = BitOrExpr();
															  el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 if (el.size() > 1)
	 {
		jjtn000.setExprList(el);
		jjtn000.setToken("&&");
		{if (true) return jjtn000;}
	 } else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTArguments Arguments() throws ParseException {
 /*@bgen(jjtree) Arguments */
  ASTArguments jjtn000 = (ASTArguments)ASTArguments.jjtCreate(this, JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList ll = new LinkedList();
  SimpleNode n;
	try {
	  jj_consume_token(LPAREN);
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case BOOLEAN:
	  case BYTE:
	  case CHAR:
	  case DOUBLE:
	  case FLOAT:
	  case INT:
	  case LONG:
	  case SHORT:
	  case IDENTIFIER:
		n = Type();
					 ll.addLast(n);
		label_14:
		while (true) {
		  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		  case COMMA:
			;
			break;
		  default:
			jj_la1[34] = jj_gen;
			break label_14;
		  }
		  jj_consume_token(COMMA);
		  n = Type();
														 ll.addLast(n);
		}
		break;
	  default:
		jj_la1[35] = jj_gen;
		;
	  }
	  jj_consume_token(RPAREN);
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	jjtn000.setArguments(ll);
	{if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTArrayExpr ArrayExpr() throws ParseException {
 /*@bgen(jjtree) ArrayExpr */
  ASTArrayExpr jjtn000 = (ASTArrayExpr)ASTArrayExpr.jjtCreate(this, JJTARRAYEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n;
	try {
	  jj_consume_token(LBRACKET);
	  n = CondExpr();
	  jj_consume_token(RBRACKET);
	 jjtree.closeNodeScope(jjtn000, true);
	 jjtc000 = false;
	 jjtn000.setExpr(n);
	 {if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	 if (jjtc000) {
	   jjtree.clearNodeScope(jjtn000);
	   jjtc000 = false;
	 } else {
	   jjtree.popNode();
	 }
	 if (jjte000 instanceof RuntimeException) {
	   {if (true) throw (RuntimeException)jjte000;}
	 }
	 if (jjte000 instanceof ParseException) {
	   {if (true) throw (ParseException)jjte000;}
	 }
	 {if (true) throw (Error)jjte000;}
	} finally {
	 if (jjtc000) {
	   jjtree.closeNodeScope(jjtn000, true);
	 }
	}
	throw new Error("Missing return statement in function");
  }  
  final public SimpleNode BitAndExpr() throws ParseException {
 /*@bgen(jjtree) BitAndExpr */
  ASTBitAndExpr jjtn000 = (ASTBitAndExpr)ASTBitAndExpr.jjtCreate(this, JJTBITANDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList el = new LinkedList();
  SimpleNode n;
	try {
	  n = EqExpr();
				 el.addLast(n);
	  label_8:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case BIT_AND:
		  ;
		  break;
		default:
		  jj_la1[11] = jj_gen;
		  break label_8;
		}
		jj_consume_token(BIT_AND);
		n = EqExpr();
													   el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 if (el.size() > 1)
	 {
		jjtn000.setExprList(el);
		jjtn000.setToken("&");
		{if (true) return jjtn000;}
	 } else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public SimpleNode BitOrExpr() throws ParseException {
 /*@bgen(jjtree) BitOrExpr */
  ASTBitOrExpr jjtn000 = (ASTBitOrExpr)ASTBitOrExpr.jjtCreate(this, JJTBITOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList el = new LinkedList();
  SimpleNode n;
	try {
	  n = BitXorExpr();
					 el.addLast(n);
	  label_6:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case BIT_OR:
		  ;
		  break;
		default:
		  jj_la1[9] = jj_gen;
		  break label_6;
		}
		jj_consume_token(BIT_OR);
		n = BitXorExpr();
															   el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 if (el.size() > 1)
	 {
		jjtn000.setExprList(el);
		jjtn000.setToken("|");
		{if (true) return jjtn000;}
	 } else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public SimpleNode BitXorExpr() throws ParseException {
 /*@bgen(jjtree) BitXorExpr */
  ASTBitXorExpr jjtn000 = (ASTBitXorExpr)ASTBitXorExpr.jjtCreate(this, JJTBITXOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList el = new LinkedList();
  SimpleNode n;
	try {
	  n = BitAndExpr();
					 el.addLast(n);
	  label_7:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case XOR:
		  ;
		  break;
		default:
		  jj_la1[10] = jj_gen;
		  break label_7;
		}
		jj_consume_token(XOR);
		n = BitAndExpr();
															   el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 if (el.size() > 1)
	 {
		jjtn000.setExprList(el);
		jjtn000.setToken("^");
		{if (true) return jjtn000;}
	 } else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTCastExpr CastExpr() throws ParseException {
 /*@bgen(jjtree) CastExpr */
  ASTCastExpr jjtn000 = (ASTCastExpr)ASTCastExpr.jjtCreate(this, JJTCASTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n;
	try {
	  jj_consume_token(LPAREN);
	  n = Type();
	  jj_consume_token(RPAREN);
						 jjtn000.setType(n);
	  n = UnaryExpr();
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 jjtn000.setExpr(n);
	 {if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
  final public void CastLookahead() throws ParseException {
 /*@bgen(jjtree) CastLookahead */
  ASTCastLookahead jjtn000 = (ASTCastLookahead)ASTCastLookahead.jjtCreate(this, JJTCASTLOOKAHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
	try {
	  if (jj_2_3(2)) {
		jj_consume_token(LPAREN);
		PrimitiveType();
	  } else if (jj_2_4(2147483647)) {
		jj_consume_token(LPAREN);
		Name();
		jj_consume_token(LBRACKET);
		jj_consume_token(RBRACKET);
	  } else {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LPAREN:
		  jj_consume_token(LPAREN);
		  Name();
		  jj_consume_token(RPAREN);
		  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		  case TILDE:
			jj_consume_token(TILDE);
			break;
		  case BANG:
			jj_consume_token(BANG);
			break;
		  case LPAREN:
			jj_consume_token(LPAREN);
			break;
		  case IDENTIFIER:
			jj_consume_token(IDENTIFIER);
			break;
		  case FALSE:
		  case NULL:
		  case TRUE:
		  case INTEGER_LITERAL:
		  case FLOATING_POINT_LITERAL:
		  case CHARACTER_LITERAL:
		  case STRING_LITERAL:
			Literal();
			break;
		  case THIS:
			jj_consume_token(THIS);
			break;
		  case SUPER:
			jj_consume_token(SUPER);
			break;
		  default:
			jj_la1[26] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		  }
		  break;
		default:
		  jj_la1[27] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
	  }
	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
  }  
/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */
  final public ASTCompilationUnit CompilationUnit() throws ParseException {
 /*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = (ASTCompilationUnit)ASTCompilationUnit.jjtCreate(this, JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n;
  PredicateImpl p = new PredicateImpl();
  Token t;
	try {
	  label_1:
	  while (true) {
		jj_consume_token(PREDICATE);
		t = jj_consume_token(IDENTIFIER);
								   p.setName(t.image);
		jj_consume_token(LBRACE);
		jj_consume_token(CLASS);
		jj_consume_token(ASSIGN);
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case GLOBAL:
		  jj_consume_token(GLOBAL);
		  jj_consume_token(SEMICOLON);
		  break;
		case IDENTIFIER:
		  n = Name();
		  jj_consume_token(SEMICOLON);
													 p.setClassContext(n.getTag());
		  jj_consume_token(METHOD);
		  jj_consume_token(ASSIGN);
		  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		  case GLOBAL:
			jj_consume_token(GLOBAL);
			jj_consume_token(SEMICOLON);
			break;
		  case IDENTIFIER:
			t = jj_consume_token(IDENTIFIER);
			n = Arguments();
			jj_consume_token(SEMICOLON);
									  p.setMethodContext(t.image,((ASTArguments) n).getArguments());
			break;
		  default:
			jj_la1[0] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		  }
		  break;
		default:
		  jj_la1[1] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
		jj_consume_token(EXPR);
		jj_consume_token(ASSIGN);
		n = CondExpr();
									p.setExprAST(n);
		jj_consume_token(SEMICOLON);
		jj_consume_token(RBRACE);
	  jjtn000.addPredicate(p);
	  p = new PredicateImpl();
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case PREDICATE:
		  ;
		  break;
		default:
		  jj_la1[2] = jj_gen;
		  break label_1;
		}
	  }
	  jj_consume_token(0);
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 {if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
/*
 * Expr syntax follows.
 */
  final public SimpleNode CondExpr() throws ParseException {
 /*@bgen(jjtree) CondExpr */
  ASTCondExpr jjtn000 = (ASTCondExpr)ASTCondExpr.jjtCreate(this, JJTCONDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode ts = null, th = null, e = null;
	try {
	  ts = OrExpr();
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case 82:
		jj_consume_token(82);
		th = CondExpr();
		jj_consume_token(83);
		e = CondExpr();
		break;
	  default:
		jj_la1[6] = jj_gen;
		;
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	if (th != null && e != null)
	{
	   jjtn000.setTestExpr(ts);
	   jjtn000.setThenExpr(th);
	   jjtn000.setElseExpr(e);
	   {if (true) return jjtn000;}
	} else {if (true) return ts;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public void disable_tracing() {
  }  
  final public ASTDotClassExpr DotClassExpr() throws ParseException {
 /*@bgen(jjtree) DotClassExpr */
  ASTDotClassExpr jjtn000 = (ASTDotClassExpr)ASTDotClassExpr.jjtCreate(this, JJTDOTCLASSEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n;
	try {
	  n = Type();
	  jj_consume_token(DOT);
	  jj_consume_token(CLASS);
	 jjtree.closeNodeScope(jjtn000, true);
	 jjtc000 = false;
	 jjtn000.setExpr(n);
	 {if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	 if (jjtc000) {
	   jjtree.clearNodeScope(jjtn000);
	   jjtc000 = false;
	 } else {
	   jjtree.popNode();
	 }
	 if (jjte000 instanceof RuntimeException) {
	   {if (true) throw (RuntimeException)jjte000;}
	 }
	 if (jjte000 instanceof ParseException) {
	   {if (true) throw (ParseException)jjte000;}
	 }
	 {if (true) throw (Error)jjte000;}
	} finally {
	 if (jjtc000) {
	   jjtree.closeNodeScope(jjtn000, true);
	 }
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTDottedExpr DottedExpr() throws ParseException {
 /*@bgen(jjtree) DottedExpr */
  ASTDottedExpr jjtn000 = (ASTDottedExpr)ASTDottedExpr.jjtCreate(this, JJTDOTTEDEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
	try {
	  if (jj_2_6(2)) {
		jj_consume_token(DOT);
		t = jj_consume_token(THIS);
	  } else {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case DOT:
		  jj_consume_token(DOT);
		  t = jj_consume_token(IDENTIFIER);
	  jjtree.closeNodeScope(jjtn000, true);
	  jjtc000 = false;
	   jjtn000.setTag(t.image);
	   {if (true) return jjtn000;}
		  break;
		default:
		  jj_la1[32] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
	  }
	} finally {
	  if (jjtc000) {
		jjtree.closeNodeScope(jjtn000, true);
	  }
	}
	throw new Error("Missing return statement in function");
  }  
  final public void enable_tracing() {
  }  
  final public SimpleNode EqExpr() throws ParseException {
 /*@bgen(jjtree) EqExpr */
  ASTEqExpr jjtn000 = (ASTEqExpr)ASTEqExpr.jjtCreate(this, JJTEQEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList tl = new LinkedList();
  LinkedList el = new LinkedList();
  Token t;
  SimpleNode n;
	try {
	  n = InstanceOfExpr();
						 el.addLast(n);
	  label_9:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case EQ:
		case NE:
		  ;
		  break;
		default:
		  jj_la1[12] = jj_gen;
		  break label_9;
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case EQ:
		  t = jj_consume_token(EQ);
		  break;
		case NE:
		  t = jj_consume_token(NE);
		  break;
		default:
		  jj_la1[13] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
							  tl.addLast(t.image);
		n = InstanceOfExpr();
																	  el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	if (!tl.isEmpty())
	{
	  jjtn000.setExprList(el);
	  jjtn000.setTokenList(tl);
	  {if (true) return jjtn000;}
	} else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ParseException generateParseException() {
	jj_expentries.removeAllElements();
	boolean[] la1tokens = new boolean[84];
	for (int i = 0; i < 84; i++) {
	  la1tokens[i] = false;
	}
	if (jj_kind >= 0) {
	  la1tokens[jj_kind] = true;
	  jj_kind = -1;
	}
	for (int i = 0; i < 36; i++) {
	  if (jj_la1[i] == jj_gen) {
		for (int j = 0; j < 32; j++) {
		  if ((jj_la1_0[i] & (1<<j)) != 0) {
			la1tokens[j] = true;
		  }
		  if ((jj_la1_1[i] & (1<<j)) != 0) {
			la1tokens[32+j] = true;
		  }
		  if ((jj_la1_2[i] & (1<<j)) != 0) {
			la1tokens[64+j] = true;
		  }
		}
	  }
	}
	for (int i = 0; i < 84; i++) {
	  if (la1tokens[i]) {
		jj_expentry = new int[1];
		jj_expentry[0] = i;
		jj_expentries.addElement(jj_expentry);
	  }
	}
	jj_endpos = 0;
	jj_rescan_token();
	jj_add_error_token(0, 0);
	int[][] exptokseq = new int[jj_expentries.size()][];
	for (int i = 0; i < jj_expentries.size(); i++) {
	  exptokseq[i] = (int[])jj_expentries.elementAt(i);
	}
	return new ParseException(token, exptokseq, tokenImage);
  }  
  final public Token getNextToken() {
	if (token.next != null) token = token.next;
	else token = token.next = token_source.getNextToken();
	jj_ntk = -1;
	jj_gen++;
	return token;
  }  
  final public Token getToken(int index) {
	Token t = lookingAhead ? jj_scanpos : token;
	for (int i = 0; i < index; i++) {
	  if (t.next != null) t = t.next;
	  else t = t.next = token_source.getNextToken();
	}
	return t;
  }  
	public static void help()
	{
		System.out.println("Predicate Parser:  Usage is one of:");
		System.out.println("         java PredicateParser < inputfile");
		System.out.println("OR");
		System.out.println("         java PredicateParser inputfile");
	}
  final public SimpleNode InstanceOfExpr() throws ParseException {
 /*@bgen(jjtree) InstanceOfExpr */
  ASTInstanceOfExpr jjtn000 = (ASTInstanceOfExpr)ASTInstanceOfExpr.jjtCreate(this, JJTINSTANCEOFEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n = null, t = null;
	try {
	  n = RelationalExpr();
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case INSTANCEOF:
		jj_consume_token(INSTANCEOF);
		t = Type();
		break;
	  default:
		jj_la1[14] = jj_gen;
		;
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 if (t != null)
	 {
		jjtn000.setType(t);
		jjtn000.setExpr(n);
		{if (true) return jjtn000;}
	 } else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final private boolean jj_2_1(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_1();
	jj_save(0, xla);
	return retval;
  }  
  final private boolean jj_2_2(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_2();
	jj_save(1, xla);
	return retval;
  }  
  final private boolean jj_2_3(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_3();
	jj_save(2, xla);
	return retval;
  }  
  final private boolean jj_2_4(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_4();
	jj_save(3, xla);
	return retval;
  }  
  final private boolean jj_2_5(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_5();
	jj_save(4, xla);
	return retval;
  }  
  final private boolean jj_2_6(int xla) {
	jj_la = xla; jj_lastpos = jj_scanpos = token;
	boolean retval = !jj_3_6();
	jj_save(5, xla);
	return retval;
  }  
  final private boolean jj_3_1() {
	if (jj_scan_token(DOT)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_2() {
	if (jj_3R_15()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_3() {
	if (jj_scan_token(LPAREN)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_16()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_4() {
	if (jj_scan_token(LPAREN)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_17()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(LBRACKET)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_5() {
	if (jj_3R_18()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(DOT)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(CLASS)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3_6() {
	if (jj_scan_token(DOT)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(THIS)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_15() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3_3()) {
	jj_scanpos = xsp;
	if (jj_3R_19()) {
	jj_scanpos = xsp;
	if (jj_3R_20()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_16() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_21()) {
	jj_scanpos = xsp;
	if (jj_3R_22()) {
	jj_scanpos = xsp;
	if (jj_3R_23()) {
	jj_scanpos = xsp;
	if (jj_3R_24()) {
	jj_scanpos = xsp;
	if (jj_3R_25()) {
	jj_scanpos = xsp;
	if (jj_3R_26()) {
	jj_scanpos = xsp;
	if (jj_3R_27()) {
	jj_scanpos = xsp;
	if (jj_3R_28()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_17() {
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3_1()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	return false;
  }  
  final private boolean jj_3R_18() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_29()) {
	jj_scanpos = xsp;
	if (jj_3R_30()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	while (true) {
	  xsp = jj_scanpos;
	  if (jj_3R_31()) { jj_scanpos = xsp; break; }
	  if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	}
	return false;
  }  
  final private boolean jj_3R_19() {
	if (jj_scan_token(LPAREN)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_17()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(LBRACKET)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(RBRACKET)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_20() {
	if (jj_scan_token(LPAREN)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_3R_17()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(RPAREN)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_32()) {
	jj_scanpos = xsp;
	if (jj_3R_33()) {
	jj_scanpos = xsp;
	if (jj_3R_34()) {
	jj_scanpos = xsp;
	if (jj_3R_35()) {
	jj_scanpos = xsp;
	if (jj_3R_36()) {
	jj_scanpos = xsp;
	if (jj_3R_37()) {
	jj_scanpos = xsp;
	if (jj_3R_38()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_21() {
	if (jj_scan_token(BOOLEAN)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_22() {
	if (jj_scan_token(CHAR)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_23() {
	if (jj_scan_token(BYTE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_24() {
	if (jj_scan_token(SHORT)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_25() {
	if (jj_scan_token(INT)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_26() {
	if (jj_scan_token(LONG)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_27() {
	if (jj_scan_token(FLOAT)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_28() {
	if (jj_scan_token(DOUBLE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_29() {
	if (jj_3R_16()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_30() {
	if (jj_3R_17()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_31() {
	if (jj_scan_token(LBRACKET)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	if (jj_scan_token(RBRACKET)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_32() {
	if (jj_scan_token(TILDE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_33() {
	if (jj_scan_token(BANG)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_34() {
	if (jj_scan_token(LPAREN)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_35() {
	if (jj_scan_token(IDENTIFIER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_36() {
	if (jj_3R_39()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_37() {
	if (jj_scan_token(THIS)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_38() {
	if (jj_scan_token(SUPER)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_39() {
	Token xsp;
	xsp = jj_scanpos;
	if (jj_3R_40()) {
	jj_scanpos = xsp;
	if (jj_3R_41()) {
	jj_scanpos = xsp;
	if (jj_3R_42()) {
	jj_scanpos = xsp;
	if (jj_3R_43()) {
	jj_scanpos = xsp;
	if (jj_3R_44()) {
	jj_scanpos = xsp;
	if (jj_3R_45()) {
	jj_scanpos = xsp;
	if (jj_3R_46()) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	} else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_40() {
	if (jj_scan_token(INTEGER_LITERAL)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_41() {
	if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_42() {
	if (jj_scan_token(CHARACTER_LITERAL)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_43() {
	if (jj_scan_token(STRING_LITERAL)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_44() {
	if (jj_scan_token(TRUE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_45() {
	if (jj_scan_token(FALSE)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  final private boolean jj_3R_46() {
	if (jj_scan_token(NULL)) return true;
	if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
	return false;
  }  
  private void jj_add_error_token(int kind, int pos) {
	if (pos >= 100) return;
	if (pos == jj_endpos + 1) {
	  jj_lasttokens[jj_endpos++] = kind;
	} else if (jj_endpos != 0) {
	  jj_expentry = new int[jj_endpos];
	  for (int i = 0; i < jj_endpos; i++) {
		jj_expentry[i] = jj_lasttokens[i];
	  }
	  boolean exists = false;
	  for (java.util.Enumeration enumVar = jj_expentries.elements(); enumVar.hasMoreElements();) {
		int[] oldentry = (int[])(enumVar.nextElement());
		if (oldentry.length == jj_expentry.length) {
		  exists = true;
		  for (int i = 0; i < jj_expentry.length; i++) {
			if (oldentry[i] != jj_expentry[i]) {
			  exists = false;
			  break;
			}
		  }
		  if (exists) break;
		}
	  }
	  if (!exists) jj_expentries.addElement(jj_expentry);
	  if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	}
  }  
  final private Token jj_consume_token(int kind) throws ParseException {
	Token oldToken;
	if ((oldToken = token).next != null) token = token.next;
	else token = token.next = token_source.getNextToken();
	jj_ntk = -1;
	if (token.kind == kind) {
	  jj_gen++;
	  if (++jj_gc > 100) {
		jj_gc = 0;
		for (int i = 0; i < jj_2_rtns.length; i++) {
		  JJCalls c = jj_2_rtns[i];
		  while (c != null) {
			if (c.gen < jj_gen) c.first = null;
			c = c.next;
		  }
		}
	  }
	  return token;
	}
	token = oldToken;
	jj_kind = kind;
	throw generateParseException();
  }  
  final private int jj_ntk() {
	if ((jj_nt=token.next) == null)
	  return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	else
	  return (jj_ntk = jj_nt.kind);
  }  
  final private void jj_rescan_token() {
	jj_rescan = true;
	for (int i = 0; i < 6; i++) {
	  JJCalls p = jj_2_rtns[i];
	  do {
		if (p.gen > jj_gen) {
		  jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
		  switch (i) {
			case 0: jj_3_1(); break;
			case 1: jj_3_2(); break;
			case 2: jj_3_3(); break;
			case 3: jj_3_4(); break;
			case 4: jj_3_5(); break;
			case 5: jj_3_6(); break;
		  }
		}
		p = p.next;
	  } while (p != null);
	}
	jj_rescan = false;
  }  
  final private void jj_save(int index, int xla) {
	JJCalls p = jj_2_rtns[index];
	while (p.gen > jj_gen) {
	  if (p.next == null) { p = p.next = new JJCalls(); break; }
	  p = p.next;
	}
	p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }  
  final private boolean jj_scan_token(int kind) {
	if (jj_scanpos == jj_lastpos) {
	  jj_la--;
	  if (jj_scanpos.next == null) {
		jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	  } else {
		jj_lastpos = jj_scanpos = jj_scanpos.next;
	  }
	} else {
	  jj_scanpos = jj_scanpos.next;
	}
	if (jj_rescan) {
	  int i = 0; Token tok = token;
	  while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	  if (tok != null) jj_add_error_token(kind, i);
	}
	return (jj_scanpos.kind != kind);
  }  
  final public ASTLiteral Literal() throws ParseException {
 /*@bgen(jjtree) Literal */
  ASTLiteral jjtn000 = (ASTLiteral)ASTLiteral.jjtCreate(this, JJTLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  Object l = null;
	try {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case INTEGER_LITERAL:
		t = jj_consume_token(INTEGER_LITERAL);
		 try {
			l = new Integer(t.image);
		 } catch (NumberFormatException e)
		 {
			try {
			   l = new Long(t.image);
			} catch (Exception ex)
			{
			   {if (true) throw new RuntimeException(ex.getMessage());}
			}
		 }
		break;
	  case FLOATING_POINT_LITERAL:
		t = jj_consume_token(FLOATING_POINT_LITERAL);
		 try {
			l = new Float(t.image);
		 } catch (NumberFormatException e)
		 {
			try {
			   l = new Double(t.image);
			} catch (Exception ex)
			{
			   {if (true) throw new RuntimeException(ex.getMessage());}
			}
		 }
		break;
	  case CHARACTER_LITERAL:
		t = jj_consume_token(CHARACTER_LITERAL);
							  l = new Character(t.image.charAt(0));
		break;
	  case STRING_LITERAL:
		t = jj_consume_token(STRING_LITERAL);
							l = t.image;
		break;
	  case TRUE:
		t = jj_consume_token(TRUE);
				  l = Boolean.TRUE;
		break;
	  case FALSE:
		t = jj_consume_token(FALSE);
				  l = Boolean.FALSE;
		break;
	  case NULL:
		t = jj_consume_token(NULL);
				  l = null;
		break;
	  default:
		jj_la1[33] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	jjtn000.setTag(t.image);
	jjtn000.setLiteral(l);
	{if (true) return jjtn000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
	public static void main (String [] args) {
		if (args.length > 1) { help(); return; }
		try {
			if (args.length == 0)
			{
				System.out.println("Predicate Parser:  Reading from standard input...");
				parse(System.in);
			} else if (args.length == 1)
			{
				System.out.println("Predicate Parser:  Reading from file " + args[0] + "...");
				parse(new FileInputStream(args[0]));
			}
		} catch (Exception e)
		{
			System.out.println(e.getMessage());
			System.out.println("Error!");
		}
	}
  final public SimpleNode MulDivExpr() throws ParseException {
 /*@bgen(jjtree) MulDivExpr */
  ASTMulDivExpr jjtn000 = (ASTMulDivExpr)ASTMulDivExpr.jjtCreate(this, JJTMULDIVEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList tl = new LinkedList();
  LinkedList el = new LinkedList();
  Token t;
  SimpleNode n;
	try {
	  n = UnaryExpr();
					el.addLast(n);
	  label_12:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case STAR:
		case SLASH:
		case REM:
		  ;
		  break;
		default:
		  jj_la1[21] = jj_gen;
		  break label_12;
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case STAR:
		  t = jj_consume_token(STAR);
		  break;
		case SLASH:
		  t = jj_consume_token(SLASH);
		  break;
		case REM:
		  t = jj_consume_token(REM);
		  break;
		default:
		  jj_la1[22] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
									  tl.addLast(t.image);
		n = UnaryExpr();
																			   el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	if (!tl.isEmpty())
	{
	  jjtn000.setExprList(el);
	  jjtn000.setTokenList(tl);
	  {if (true) return jjtn000;}
	} else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTName Name() throws ParseException {
 /*@bgen(jjtree) Name */
  ASTName jjtn000 = (ASTName)ASTName.jjtCreate(this, JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String s;
	try {
	  t = jj_consume_token(IDENTIFIER);
					 s = t.image;
	  label_3:
	  while (true) {
		if (jj_2_1(2)) {
		  ;
		} else {
		  break label_3;
		}
		jj_consume_token(DOT);
		t = jj_consume_token(IDENTIFIER);
										s += "." + t.image;
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 jjtn000.setTag(s);
	 {if (true) return jjtn000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public SimpleNode OrExpr() throws ParseException {
 /*@bgen(jjtree) OrExpr */
  ASTOrExpr jjtn000 = (ASTOrExpr)ASTOrExpr.jjtCreate(this, JJTOREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList el = new LinkedList();
  SimpleNode n;
	try {
	  n = AndExpr();
				  el.addLast(n);
	  label_4:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case SC_OR:
		  ;
		  break;
		default:
		  jj_la1[7] = jj_gen;
		  break label_4;
		}
		jj_consume_token(SC_OR);
		n = AndExpr();
														  el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 if (el.size() > 1)
	 {
		jjtn000.setExprList(el);
		jjtn000.setToken("||");
		{if (true) return jjtn000;}
	 } else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
	public static ASTCompilationUnit parse(InputStream i) throws ParseException
	{
		PredicateParser parser = new PredicateParser(i);
		return parser.CompilationUnit();
	}
  final public ASTPrimaryExpr PrimaryExpr() throws ParseException {
 /*@bgen(jjtree) PrimaryExpr */
  ASTPrimaryExpr jjtn000 = (ASTPrimaryExpr)ASTPrimaryExpr.jjtCreate(this, JJTPRIMARYEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n = null, p = null;
  LinkedList l = new LinkedList();
  int pref = -1;
	try {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case FALSE:
	  case NULL:
	  case TRUE:
	  case INTEGER_LITERAL:
	  case FLOATING_POINT_LITERAL:
	  case CHARACTER_LITERAL:
	  case STRING_LITERAL:
		p = Literal();
						   pref = 1;
		break;
	  case LPAREN:
		jj_consume_token(LPAREN);
		p = CondExpr();
		jj_consume_token(RPAREN);
							   pref = 2;
		break;
	  case THIS:
		p = ThisExpr();
						   pref = 3;
		break;
	  case SUPER:
		p = SuperExpr();
						   pref = 4;
		break;
	  default:
		jj_la1[28] = jj_gen;
		if (jj_2_5(2147483647)) {
		  p = DotClassExpr();
														   pref = 5;
		} else {
		  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		  case IDENTIFIER:
			p = Name();
						   pref = 6;
			break;
		  default:
			jj_la1[29] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		  }
		}
	  }
	  label_13:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LBRACKET:
		case DOT:
		  ;
		  break;
		default:
		  jj_la1[30] = jj_gen;
		  break label_13;
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LBRACKET:
		  n = ArrayExpr();
		if (pref != 6) {if (true) throw new RuntimeException("Invalid combination");}
		if (p != null)
		{
			n.setTag(p.getTag());
			p = null;
		}
		l.addLast(n);
		  break;
		case DOT:
		  n = DottedExpr();
		if (pref == 1 || pref == 3 || pref == 4 || pref == 5 || pref == 7) {if (true) throw new RuntimeException("Invalid combination");}
		if (p != null)
		{
			((ASTDottedExpr) n).setContext(p.getTag());
			p = null;
		} else {if (true) throw new RuntimeException("Not handled yet!");}

		if (!n.getTag().equals("this"))
		{
			pref = 6;
			{if (true) throw new RuntimeException("Not supported yet!");}
		} else
		{
			pref = 7;
		}
		l.addLast(n);
		  break;
		default:
		  jj_la1[31] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	if (p != null) l.addLast(p);
	jjtn000.setNodes(l);
	{if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTPrimitiveType PrimitiveType() throws ParseException {
 /*@bgen(jjtree) PrimitiveType */
  ASTPrimitiveType jjtn000 = (ASTPrimitiveType)ASTPrimitiveType.jjtCreate(this, JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
	try {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case BOOLEAN:
		t = jj_consume_token(BOOLEAN);
		break;
	  case CHAR:
		t = jj_consume_token(CHAR);
		break;
	  case BYTE:
		t = jj_consume_token(BYTE);
		break;
	  case SHORT:
		t = jj_consume_token(SHORT);
		break;
	  case INT:
		t = jj_consume_token(INT);
		break;
	  case LONG:
		t = jj_consume_token(LONG);
		break;
	  case FLOAT:
		t = jj_consume_token(FLOAT);
		break;
	  case DOUBLE:
		t = jj_consume_token(DOUBLE);
		break;
	  default:
		jj_la1[5] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	jjtn000.setTag(t.image);
	{if (true) return jjtn000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  public void ReInit(PredicateParserTokenManager tm) {
	token_source = tm;
	token = new Token();
	jj_ntk = -1;
	jjtree.reset();
	jj_gen = 0;
	for (int i = 0; i < 36; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  public void ReInit(java.io.InputStream stream) {
	jj_input_stream.ReInit(stream, 1, 1);
	token_source.ReInit(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jjtree.reset();
	jj_gen = 0;
	for (int i = 0; i < 36; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  public void ReInit(java.io.Reader stream) {
	jj_input_stream.ReInit(stream, 1, 1);
	token_source.ReInit(jj_input_stream);
	token = new Token();
	jj_ntk = -1;
	jjtree.reset();
	jj_gen = 0;
	for (int i = 0; i < 36; i++) jj_la1[i] = -1;
	for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }  
  final public SimpleNode RelationalExpr() throws ParseException {
 /*@bgen(jjtree) RelationalExpr */
  ASTRelationalExpr jjtn000 = (ASTRelationalExpr)ASTRelationalExpr.jjtCreate(this, JJTRELATIONALEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  SimpleNode n;
	try {
	  n = ShiftExpr();
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case GT:
	  case LT:
	  case LE:
	  case GE:
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LT:
		  t = jj_consume_token(LT);
		  break;
		case GT:
		  t = jj_consume_token(GT);
		  break;
		case LE:
		  t = jj_consume_token(LE);
		  break;
		case GE:
		  t = jj_consume_token(GE);
		  break;
		default:
		  jj_la1[15] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
	   jjtn000.setTag(t.image);
	   jjtn000.setOp1(n);
		n = ShiftExpr();
						jjtn000.setOp2(n); {if (true) return jjtn000;}
		break;
	  default:
		jj_la1[16] = jj_gen;
		;
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	{if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public SimpleNode ShiftExpr() throws ParseException {
 /*@bgen(jjtree) ShiftExpr */
  ASTShiftExpr jjtn000 = (ASTShiftExpr)ASTShiftExpr.jjtCreate(this, JJTSHIFTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);LinkedList tl = new LinkedList();
  LinkedList el = new LinkedList();
  Token t;
  SimpleNode n;
	try {
	  n = AddSubExpr();
					 el.addLast(n);
	  label_10:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LSHIFT:
		case RSIGNEDSHIFT:
		case RUNSIGNEDSHIFT:
		  ;
		  break;
		default:
		  jj_la1[17] = jj_gen;
		  break label_10;
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LSHIFT:
		  t = jj_consume_token(LSHIFT);
		  break;
		case RSIGNEDSHIFT:
		  t = jj_consume_token(RSIGNEDSHIFT);
		  break;
		case RUNSIGNEDSHIFT:
		  t = jj_consume_token(RUNSIGNEDSHIFT);
		  break;
		default:
		  jj_la1[18] = jj_gen;
		  jj_consume_token(-1);
		  throw new ParseException();
		}
										  tl.addLast(t.image);
		n = AddSubExpr();
																			  el.addLast(n);
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	if (!tl.isEmpty())
	{
	  jjtn000.setExprList(el);
	  jjtn000.setTokenList(tl);
	  {if (true) return jjtn000;}
	} else {if (true) return n;}  // Skip pass-thru

	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTSuperExpr SuperExpr() throws ParseException {
 /*@bgen(jjtree) SuperExpr */
  ASTSuperExpr jjtn000 = (ASTSuperExpr)ASTSuperExpr.jjtCreate(this, JJTSUPEREXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
	try {
	  jj_consume_token(SUPER);
	  jj_consume_token(DOT);
	  t = jj_consume_token(IDENTIFIER);
	 jjtree.closeNodeScope(jjtn000, true);
	 jjtc000 = false;
	  jjtn000.setTag(t.image);
	  {if (true) return jjtn000;}
	} finally {
	 if (jjtc000) {
	   jjtree.closeNodeScope(jjtn000, true);
	 }
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTThisExpr ThisExpr() throws ParseException {
 /*@bgen(jjtree) ThisExpr */
  ASTThisExpr jjtn000 = (ASTThisExpr)ASTThisExpr.jjtCreate(this, JJTTHISEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
	try {
	  jj_consume_token(THIS);
			jjtree.closeNodeScope(jjtn000, true);
			jjtc000 = false;
			{if (true) return jjtn000;}
	} finally {
	 if (jjtc000) {
	   jjtree.closeNodeScope(jjtn000, true);
	 }
	}
	throw new Error("Missing return statement in function");
  }  
/*
 * Type, name and Expr syntax follows.
 */
  final public ASTType Type() throws ParseException {
 /*@bgen(jjtree) Type */
  ASTType jjtn000 = (ASTType)ASTType.jjtCreate(this, JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n;
  int dim = 0;
	try {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case BOOLEAN:
	  case BYTE:
	  case CHAR:
	  case DOUBLE:
	  case FLOAT:
	  case INT:
	  case LONG:
	  case SHORT:
		n = PrimitiveType();
		break;
	  case IDENTIFIER:
		n = Name();
		break;
	  default:
		jj_la1[3] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	  }
	  label_2:
	  while (true) {
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LBRACKET:
		  ;
		  break;
		default:
		  jj_la1[4] = jj_gen;
		  break label_2;
		}
		jj_consume_token(LBRACKET);
		jj_consume_token(RBRACKET);
												   dim++;
	  }
	jjtree.closeNodeScope(jjtn000, true);
	jjtc000 = false;
	 String s = n.getTag();
	 jjtn000.setBaseType(s);
	 if (dim > 0)
	 {
		for (int i = 0; i < dim; i++) s += "[]";
		jjtn000.setDimension(dim);
	 }
	 jjtn000.setTag(s);
	 {if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTUnaryExpr UnaryExpr() throws ParseException {
 /*@bgen(jjtree) UnaryExpr */
  ASTUnaryExpr jjtn000 = (ASTUnaryExpr)ASTUnaryExpr.jjtCreate(this, JJTUNARYEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n;
	try {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case BANG:
	  case TILDE:
	  case PLUS:
	  case MINUS:
		n = UnaryMathExpr();
		break;
	  default:
		jj_la1[23] = jj_gen;
		if (jj_2_2(2147483647)) {
		  n = CastExpr();
		} else {
		  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		  case BOOLEAN:
		  case BYTE:
		  case CHAR:
		  case DOUBLE:
		  case FALSE:
		  case FLOAT:
		  case INT:
		  case LONG:
		  case NULL:
		  case SUPER:
		  case SHORT:
		  case THIS:
		  case TRUE:
		  case INTEGER_LITERAL:
		  case FLOATING_POINT_LITERAL:
		  case CHARACTER_LITERAL:
		  case STRING_LITERAL:
		  case IDENTIFIER:
		  case LPAREN:
			n = PrimaryExpr();
			break;
		  default:
			jj_la1[24] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		  }
		}
	  }
	 jjtree.closeNodeScope(jjtn000, true);
	 jjtc000 = false;
	 jjtn000.setExpr(n);
	 {if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	 if (jjtc000) {
	   jjtree.clearNodeScope(jjtn000);
	   jjtc000 = false;
	 } else {
	   jjtree.popNode();
	 }
	 if (jjte000 instanceof RuntimeException) {
	   {if (true) throw (RuntimeException)jjte000;}
	 }
	 if (jjte000 instanceof ParseException) {
	   {if (true) throw (ParseException)jjte000;}
	 }
	 {if (true) throw (Error)jjte000;}
	} finally {
	 if (jjtc000) {
	   jjtree.closeNodeScope(jjtn000, true);
	 }
	}
	throw new Error("Missing return statement in function");
  }  
  final public ASTUnaryMathExpr UnaryMathExpr() throws ParseException {
 /*@bgen(jjtree) UnaryMathExpr */
  ASTUnaryMathExpr jjtn000 = (ASTUnaryMathExpr)ASTUnaryMathExpr.jjtCreate(this, JJTUNARYMATHEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);SimpleNode n;
  Token t;
	try {
	  switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
	  case PLUS:
		t = jj_consume_token(PLUS);
		break;
	  case MINUS:
		t = jj_consume_token(MINUS);
		break;
	  case TILDE:
		t = jj_consume_token(TILDE);
		break;
	  case BANG:
		t = jj_consume_token(BANG);
		break;
	  default:
		jj_la1[25] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
	  }
	  n = UnaryExpr();
	 jjtree.closeNodeScope(jjtn000, true);
	 jjtc000 = false;
	 jjtn000.setTag(t.image);
	 jjtn000.setExpr(n);
	 {if (true) return jjtn000;}
	} catch (Throwable jjte000) {
	if (jjtc000) {
	  jjtree.clearNodeScope(jjtn000);
	  jjtc000 = false;
	} else {
	  jjtree.popNode();
	}
	if (jjte000 instanceof RuntimeException) {
	  {if (true) throw (RuntimeException)jjte000;}
	}
	if (jjte000 instanceof ParseException) {
	  {if (true) throw (ParseException)jjte000;}
	}
	{if (true) throw (Error)jjte000;}
	} finally {
	if (jjtc000) {
	  jjtree.closeNodeScope(jjtn000, true);
	}
	}
	throw new Error("Missing return statement in function");
  }  
}
