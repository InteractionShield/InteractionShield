package edu.ksu.cis.bandera.abstraction.options.parser;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Bandera, a Java(TM) analysis and transformation toolkit           *
 * Copyright (C) 1998-2001 SAnToS Laboratories (santos@cis.ksu.edu)  *

 * All rights reserved.                                              *
 *                                                                   *
 * This work was done as a project in the SAnToS Laboratory,         *
 * Department of Computing and Information Sciences, Kansas State    *
 * University, USA (http://www.cis.ksu.edu/santos).                  *
 * It is understood that any modification not identified as such is  *
 * not covered by the preceding statement.                           *
 *                                                                   *
 * This work is free software; you can redistribute it and/or        *
 * modify it under the terms of the GNU Library General Public       *
 * License as published by the Free Software Foundation; either      *
 * version 2 of the License, or (at your option) any later version.  *
 *                                                                   *
 * This work is distributed in the hope that it will be useful,      *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of    *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *
 * Library General Public License for more details.                  *
 *                                                                   *
 * You should have received a copy of the GNU Library General Public *
 * License along with this toolkit; if not, write to the             *
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,      *
 * Boston, MA  02111-1307, USA.                                      *
 *                                                                   *
 * Java is a trademark of Sun Microsystems, Inc.                     *
 *                                                                   *
 * To submit a bug report, send a comment, or get the latest news on *
 * this project and other SAnToS projects, please visit the web-site *
 *                http://www.cis.ksu.edu/santos                      *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/* This file was generated by SableCC (http://www.sable.mcgill.ca/sablecc/). */

import edu.ksu.cis.bandera.abstraction.options.lexer.*;
import edu.ksu.cis.bandera.abstraction.options.node.*;
import edu.ksu.cis.bandera.abstraction.options.analysis.*;
import java.util.*;

import java.io.DataInputStream;
import java.io.BufferedInputStream;
import java.io.IOException;

public class Parser
{
	public final Analysis ignoredTokens = new AnalysisAdapter();

	protected Node node;

	private final Lexer lexer;
	private final ListIterator stack = new LinkedList().listIterator();
	private int last_shift;
	private int last_pos;
	private int last_line;
	private final TokenIndex converter = new TokenIndex();
	private final int[] action = new int[2];

	private final static int SHIFT = 0;
	private final static int REDUCE = 1;
	private final static int ACCEPT = 2;
	private final static int ERROR = 3;

	private static int[][][] actionTable;
/*      {
			{{-1, REDUCE, 0}, {8, SHIFT, 1}, },
			{{-1, ERROR, 1}, {9, SHIFT, 5}, },
			{{-1, ERROR, 2}, {10, ACCEPT, -1}, },
			{{-1, REDUCE, 3}, },
			{{-1, REDUCE, 1}, {8, SHIFT, 1}, },
			{{-1, REDUCE, 12}, },
			{{-1, ERROR, 6}, {0, SHIFT, 8}, {5, SHIFT, 9}, },
			{{-1, REDUCE, 2}, },
			{{-1, ERROR, 8}, {1, SHIFT, 10}, {9, SHIFT, 11}, },
			{{-1, ERROR, 9}, {9, SHIFT, 16}, },
			{{-1, REDUCE, 4}, },
			{{-1, ERROR, 11}, {2, SHIFT, 17}, {9, SHIFT, 5}, },
			{{-1, REDUCE, 7}, },
			{{-1, REDUCE, 10}, },
			{{-1, ERROR, 14}, {1, SHIFT, 19}, {9, SHIFT, 11}, },
			{{-1, ERROR, 15}, {1, SHIFT, 22}, {9, SHIFT, 23}, },
			{{-1, REDUCE, 13}, },
			{{-1, ERROR, 17}, {3, SHIFT, 25}, {9, SHIFT, 5}, },
			{{-1, ERROR, 18}, {5, SHIFT, 9}, {6, SHIFT, 28}, },
			{{-1, REDUCE, 5}, },
			{{-1, REDUCE, 6}, },
			{{-1, ERROR, 21}, {1, SHIFT, 29}, {9, SHIFT, 23}, },
			{{-1, REDUCE, 8}, },
			{{-1, ERROR, 23}, {2, SHIFT, 17}, },
			{{-1, REDUCE, 9}, },
			{{-1, ERROR, 25}, {0, SHIFT, 30}, },
			{{-1, REDUCE, 21}, {4, SHIFT, 31}, {5, SHIFT, 9}, },
			{{-1, ERROR, 27}, {3, SHIFT, 33}, {7, SHIFT, 34}, },
			{{-1, REDUCE, 14}, },
			{{-1, REDUCE, 11}, },
			{{-1, ERROR, 30}, {1, SHIFT, 35}, {9, SHIFT, 36}, },
			{{-1, REDUCE, 24}, },
			{{-1, REDUCE, 22}, {4, SHIFT, 39}, },
			{{-1, ERROR, 33}, {0, SHIFT, 40}, },
			{{-1, ERROR, 34}, {9, SHIFT, 5}, },
			{{-1, REDUCE, 15}, },
			{{-1, ERROR, 36}, {9, SHIFT, 5}, },
			{{-1, REDUCE, 19}, },
			{{-1, ERROR, 38}, {1, SHIFT, 43}, {9, SHIFT, 36}, },
			{{-1, REDUCE, 23}, },
			{{-1, ERROR, 40}, {1, SHIFT, 45}, {9, SHIFT, 36}, },
			{{-1, REDUCE, 25}, {4, SHIFT, 31}, {5, SHIFT, 9}, },
			{{-1, ERROR, 42}, {5, SHIFT, 9}, {6, SHIFT, 48}, },
			{{-1, REDUCE, 17}, },
			{{-1, REDUCE, 18}, },
			{{-1, REDUCE, 16}, },
			{{-1, ERROR, 46}, {1, SHIFT, 49}, {9, SHIFT, 36}, },
			{{-1, REDUCE, 26}, {4, SHIFT, 39}, },
			{{-1, REDUCE, 27}, },
			{{-1, REDUCE, 20}, },
		};*/
	private static int[][][] gotoTable;
/*      {
			{{-1, 2}, },
			{{-1, 3}, {4, 7}, },
			{{-1, 6}, {11, 18}, {17, 26}, {34, 41}, {36, 42}, },
			{{-1, 12}, {14, 20}, },
			{{-1, 13}, {15, 24}, {21, 24}, },
			{{-1, 27}, },
			{{-1, 37}, {38, 44}, {46, 44}, },
			{{-1, 4}, },
			{{-1, 14}, },
			{{-1, 15}, {14, 21}, },
			{{-1, 38}, {40, 46}, },
			{{-1, 32}, {41, 47}, },
		};*/
	private static String[] errorMessages;
/*      {
			"TCls EOF expected.",
			"TId expected.",
			"EOF expected.",
			"TLBrace TRParen TDim TDot TSemicolon TComma expected.",
			"TLBrace TDot expected.",
			"TRBrace TId expected.",
			"TLParen TId expected.",
			"TRParen TId expected.",
			"TDot TSemicolon expected.",
			"TLParen expected.",
			"TLBrace expected.",
			"TRParen TDim TDot TComma expected.",
			"TRParen TComma expected.",
			"TRParen TDim TComma expected.",
		};*/
	private static int[] errors;
/*      {
			0, 1, 2, 0, 0, 3, 4, 0, 5, 1, 0, 6, 5, 5, 5, 5, 3, 7, 8, 0, 5, 5, 0, 9, 5, 10, 11, 12, 5, 0, 5, 13, 13, 10, 1, 5, 1, 5, 5, 13, 5, 11, 8, 5, 5, 5, 5, 13, 5, 5, 
		};*/
	public Parser(Lexer lexer)
	{
		this.lexer = lexer;

		if(actionTable == null)
		{
			try
			{
				DataInputStream s = new DataInputStream(
					new BufferedInputStream(
					Parser.class.getResourceAsStream("parser.dat")));

				// read actionTable
				int length = s.readInt();
				actionTable = new int[length][][];
				for(int i = 0; i < actionTable.length; i++)
				{
					length = s.readInt();
					actionTable[i] = new int[length][3];
					for(int j = 0; j < actionTable[i].length; j++)
					{
						for(int k = 0; k < 3; k++)
						{
							actionTable[i][j][k] = s.readInt();
						}
					}
				}

				// read gotoTable
				length = s.readInt();
				gotoTable = new int[length][][];
				for(int i = 0; i < gotoTable.length; i++)
				{
					length = s.readInt();
					gotoTable[i] = new int[length][2];
					for(int j = 0; j < gotoTable[i].length; j++)
					{
						for(int k = 0; k < 2; k++)
						{
							gotoTable[i][j][k] = s.readInt();
						}
					}
				}

				// read errorMessages
				length = s.readInt();
				errorMessages = new String[length];
				for(int i = 0; i < errorMessages.length; i++)
				{
					length = s.readInt();
					StringBuffer buffer = new StringBuffer();

					for(int j = 0; j < length; j++)
					{
						buffer.append(s.readChar());
					}
					errorMessages[i] = buffer.toString();
				}

				// read errors
				length = s.readInt();
				errors = new int[length];
				for(int i = 0; i < errors.length; i++)
				{
					errors[i] = s.readInt();
				}

				s.close();
			}
			catch(Exception e)
			{
				throw new RuntimeException("Unable to read parser.dat.");
			}
		}
	}
	protected void filter() throws ParserException, LexerException, IOException
	{
	}
	private int goTo(int index)
	{
		int state = state();
		int low = 1;
		int high = gotoTable[index].length - 1;
		int value = gotoTable[index][0][1];

		while(low <= high)
		{
			int middle = (low + high) / 2;

			if(state < gotoTable[index][middle][0])
			{
				high = middle - 1;
			}
			else if(state > gotoTable[index][middle][0])
			{
				low = middle + 1;
			}
			else
			{
				value = gotoTable[index][middle][1];
				break;
			}
		}

		return value;
	}
	private int index(Switchable token)
	{
		converter.index = -1;
		token.apply(converter);
		return converter.index;
	}
	Node new0()
	{
		XPClassOption node1 = null;
		AUnit node = new AUnit(node1);
		return node;
	}
	Node new1()
	{
		XPClassOption node1 = (XPClassOption) pop();
		AUnit node = new AUnit(node1);
		return node;
	}
	Node new10()
	{
		PMethodOption node1 = (PMethodOption) pop();
		X2PMethodOption node = new X2PMethodOption(node1);
		return node;
	}
	Node new11()
	{
		TRBrace node6 = (TRBrace) pop();
		XPMethodOption node5 = (XPMethodOption) pop();
		XPFieldOption node4 = (XPFieldOption) pop();
		TLBrace node3 = (TLBrace) pop();
		PName node2 = (PName) pop();
		TCls node1 = (TCls) pop();
		AClassOption node = new AClassOption(node1, node2, node3, node4, node5, node6);
		return node;
	}
	Node new12()
	{
		TId node1 = (TId) pop();
		ASimpleName node = new ASimpleName(node1);
		return node;
	}
	Node new13()
	{
		TId node3 = (TId) pop();
		TDot node2 = (TDot) pop();
		PName node1 = (PName) pop();
		AQualifiedName node = new AQualifiedName(node1, node2, node3);
		return node;
	}
	Node new14()
	{
		TSemicolon node3 = (TSemicolon) pop();
		PName node2 = (PName) pop();
		TId node1 = (TId) pop();
		AFieldOption node = new AFieldOption(node1, node2, node3);
		return node;
	}
	Node new15()
	{
		TRBrace node7 = (TRBrace) pop();
		XPLocalOption node6 = null;
		TLBrace node5 = (TLBrace) pop();
		TRParen node4 = (TRParen) pop();
		PParams node3 = null;
		TLParen node2 = (TLParen) pop();
		TId node1 = (TId) pop();
		AMethodOption node = new AMethodOption(node1, node2, node3, node4, node5, node6, node7);
		return node;
	}
	Node new16()
	{
		TRBrace node7 = (TRBrace) pop();
		XPLocalOption node6 = null;
		TLBrace node5 = (TLBrace) pop();
		TRParen node4 = (TRParen) pop();
		PParams node3 = (PParams) pop();
		TLParen node2 = (TLParen) pop();
		TId node1 = (TId) pop();
		AMethodOption node = new AMethodOption(node1, node2, node3, node4, node5, node6, node7);
		return node;
	}
	Node new17()
	{
		TRBrace node7 = (TRBrace) pop();
		XPLocalOption node6 = (XPLocalOption) pop();
		TLBrace node5 = (TLBrace) pop();
		TRParen node4 = (TRParen) pop();
		PParams node3 = null;
		TLParen node2 = (TLParen) pop();
		TId node1 = (TId) pop();
		AMethodOption node = new AMethodOption(node1, node2, node3, node4, node5, node6, node7);
		return node;
	}
	Node new18()
	{
		PLocalOption node2 = (PLocalOption) pop();
		XPLocalOption node1 = (XPLocalOption) pop();
		X1PLocalOption node = new X1PLocalOption(node1, node2);
		return node;
	}
	Node new19()
	{
		PLocalOption node1 = (PLocalOption) pop();
		X2PLocalOption node = new X2PLocalOption(node1);
		return node;
	}
	Node new2()
	{
		PClassOption node2 = (PClassOption) pop();
		XPClassOption node1 = (XPClassOption) pop();
		X1PClassOption node = new X1PClassOption(node1, node2);
		return node;
	}
	Node new20()
	{
		TRBrace node7 = (TRBrace) pop();
		XPLocalOption node6 = (XPLocalOption) pop();
		TLBrace node5 = (TLBrace) pop();
		TRParen node4 = (TRParen) pop();
		PParams node3 = (PParams) pop();
		TLParen node2 = (TLParen) pop();
		TId node1 = (TId) pop();
		AMethodOption node = new AMethodOption(node1, node2, node3, node4, node5, node6, node7);
		return node;
	}
	Node new21()
	{
		XTDim node2 = null;
		PName node1 = (PName) pop();
		AParamParams node = new AParamParams(node1, node2);
		return node;
	}
	Node new22()
	{
		XTDim node2 = (XTDim) pop();
		PName node1 = (PName) pop();
		AParamParams node = new AParamParams(node1, node2);
		return node;
	}
	Node new23()
	{
		TDim node2 = (TDim) pop();
		XTDim node1 = (XTDim) pop();
		X1TDim node = new X1TDim(node1, node2);
		return node;
	}
	Node new24()
	{
		TDim node1 = (TDim) pop();
		X2TDim node = new X2TDim(node1);
		return node;
	}
	Node new25()
	{
		XTDim node4 = null;
		PName node3 = (PName) pop();
		TComma node2 = (TComma) pop();
		PParams node1 = (PParams) pop();
		AParamsParams node = new AParamsParams(node1, node2, node3, node4);
		return node;
	}
	Node new26()
	{
		XTDim node4 = (XTDim) pop();
		PName node3 = (PName) pop();
		TComma node2 = (TComma) pop();
		PParams node1 = (PParams) pop();
		AParamsParams node = new AParamsParams(node1, node2, node3, node4);
		return node;
	}
	Node new27()
	{
		TSemicolon node3 = (TSemicolon) pop();
		PName node2 = (PName) pop();
		TId node1 = (TId) pop();
		ALocalOption node = new ALocalOption(node1, node2, node3);
		return node;
	}
	Node new3()
	{
		PClassOption node1 = (PClassOption) pop();
		X2PClassOption node = new X2PClassOption(node1);
		return node;
	}
	Node new4()
	{
		TRBrace node6 = (TRBrace) pop();
		XPMethodOption node5 = null;
		XPFieldOption node4 = null;
		TLBrace node3 = (TLBrace) pop();
		PName node2 = (PName) pop();
		TCls node1 = (TCls) pop();
		AClassOption node = new AClassOption(node1, node2, node3, node4, node5, node6);
		return node;
	}
	Node new5()
	{
		TRBrace node6 = (TRBrace) pop();
		XPMethodOption node5 = null;
		XPFieldOption node4 = (XPFieldOption) pop();
		TLBrace node3 = (TLBrace) pop();
		PName node2 = (PName) pop();
		TCls node1 = (TCls) pop();
		AClassOption node = new AClassOption(node1, node2, node3, node4, node5, node6);
		return node;
	}
	Node new6()
	{
		PFieldOption node2 = (PFieldOption) pop();
		XPFieldOption node1 = (XPFieldOption) pop();
		X1PFieldOption node = new X1PFieldOption(node1, node2);
		return node;
	}
	Node new7()
	{
		PFieldOption node1 = (PFieldOption) pop();
		X2PFieldOption node = new X2PFieldOption(node1);
		return node;
	}
	Node new8()
	{
		TRBrace node6 = (TRBrace) pop();
		XPMethodOption node5 = (XPMethodOption) pop();
		XPFieldOption node4 = null;
		TLBrace node3 = (TLBrace) pop();
		PName node2 = (PName) pop();
		TCls node1 = (TCls) pop();
		AClassOption node = new AClassOption(node1, node2, node3, node4, node5, node6);
		return node;
	}
	Node new9()
	{
		PMethodOption node2 = (PMethodOption) pop();
		XPMethodOption node1 = (XPMethodOption) pop();
		X1PMethodOption node = new X1PMethodOption(node1, node2);
		return node;
	}
	public Start parse() throws ParserException, LexerException, IOException
	{
		push(0, null, false);

		List ign = null;
		while(true)
		{
			while(index(lexer.peek()) == -1)
			{
				if(ign == null)
				{
					ign = new TypedLinkedList(NodeCast.instance);
				}

				ign.add(lexer.next());
			}

			if(ign != null)
			{
				ignoredTokens.setIn(lexer.peek(), ign);
				ign = null;
			}

			last_pos = lexer.peek().getPos();
			last_line = lexer.peek().getLine();

			int index = index(lexer.peek());
			action[0] = actionTable[state()][0][1];
			action[1] = actionTable[state()][0][2];

			int low = 1;
			int high = actionTable[state()].length - 1;

			while(low <= high)
			{
				int middle = (low + high) / 2;

				if(index < actionTable[state()][middle][0])
				{
					high = middle - 1;
				}
				else if(index > actionTable[state()][middle][0])
				{
					low = middle + 1;
				}
				else
				{
					action[0] = actionTable[state()][middle][1];
					action[1] = actionTable[state()][middle][2];
					break;
				}
			}

			switch(action[0])
			{
				case SHIFT:
					push(action[1], lexer.next(), true);
					last_shift = action[1];
					break;
				case REDUCE:
					switch(action[1])
					{
					case 0: { Node node = new0(); push(goTo(0), node, true); } break;
					case 1: { Node node = new1(); push(goTo(0), node, true); } break;
					case 2: { Node node = new2(); push(goTo(7), node, false); } break;
					case 3: { Node node = new3(); push(goTo(7), node, false); } break;
					case 4: { Node node = new4(); push(goTo(1), node, true); } break;
					case 5: { Node node = new5(); push(goTo(1), node, true); } break;
					case 6: { Node node = new6(); push(goTo(8), node, false); } break;
					case 7: { Node node = new7(); push(goTo(8), node, false); } break;
					case 8: { Node node = new8(); push(goTo(1), node, true); } break;
					case 9: { Node node = new9(); push(goTo(9), node, false); } break;
					case 10: { Node node = new10(); push(goTo(9), node, false); } break;
					case 11: { Node node = new11(); push(goTo(1), node, true); } break;
					case 12: { Node node = new12(); push(goTo(2), node, true); } break;
					case 13: { Node node = new13(); push(goTo(2), node, true); } break;
					case 14: { Node node = new14(); push(goTo(3), node, true); } break;
					case 15: { Node node = new15(); push(goTo(4), node, true); } break;
					case 16: { Node node = new16(); push(goTo(4), node, true); } break;
					case 17: { Node node = new17(); push(goTo(4), node, true); } break;
					case 18: { Node node = new18(); push(goTo(10), node, false); } break;
					case 19: { Node node = new19(); push(goTo(10), node, false); } break;
					case 20: { Node node = new20(); push(goTo(4), node, true); } break;
					case 21: { Node node = new21(); push(goTo(5), node, true); } break;
					case 22: { Node node = new22(); push(goTo(5), node, true); } break;
					case 23: { Node node = new23(); push(goTo(11), node, false); } break;
					case 24: { Node node = new24(); push(goTo(11), node, false); } break;
					case 25: { Node node = new25(); push(goTo(5), node, true); } break;
					case 26: { Node node = new26(); push(goTo(5), node, true); } break;
					case 27: { Node node = new27(); push(goTo(6), node, true); } break;
					}
					break;
				case ACCEPT:
					{
						EOF node2 = (EOF) lexer.next();
						PUnit node1 = (PUnit) pop();
						Start node = new Start(node1, node2);
						return node;
					}
				case ERROR:
					throw new ParserException(
						"[" + last_line + "," + last_pos + "] " +
						errorMessages[errors[action[1]]]);
			}
		}
	}
	private Node pop()
	{
		return (Node) ((State) stack.previous()).node;
	}
	private void push(int state, Node node, boolean filter) throws ParserException, LexerException, IOException
	{
		this.node = node;

		if(filter)
		{
			filter();
		}

		if(!stack.hasNext())
		{
			stack.add(new State(state, this.node));
			return;
		}

		State s = (State) stack.next();
		s.state = state;
		s.node = this.node;
	}
	private int state()
	{
		State s = (State) stack.previous();
		stack.next();
		return s.state;
	}
}
